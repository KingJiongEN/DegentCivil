{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Town Simulation Service","text":"<p>Welcome to the Town Simulation Service documentation! This service provides a sophisticated backend system for simulating town operations with AI-driven characters, real-time interactions, and dynamic state management.</p>"},{"location":"#overview","title":"Overview","text":"<p>Town Simulation Service is a powerful backend service that creates a living, breathing virtual town environment. It combines advanced AI technologies with real-time simulation to create dynamic and interactive town scenarios.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>AI-Driven Characters: Intelligent NPCs with autonomous behavior and decision-making capabilities</li> <li>Dynamic State Management: Sophisticated state system for managing character behaviors and interactions</li> <li>Real-time Simulation: Live updates and interactions within the town environment</li> <li>Memory System: Advanced memory management for character experiences and knowledge</li> <li>Building System: Flexible building management and interaction system</li> <li>LLM Integration: Seamless integration with Large Language Models for natural interactions</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>\ud83d\ude80 Quick Start Guide</li> <li>\ud83d\udcda Core Concepts</li> <li>\ud83d\udd27 API Reference</li> <li>\ud83d\udca1 Examples</li> <li>\ud83d\udc65 Contributing Guide</li> </ul>"},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.8 or higher</li> <li>Docker (for Milvus and Redis)</li> <li>OpenAI API access (or compatible LLM service)</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you encounter any issues or have questions:</p> <ol> <li>Check our Troubleshooting Guide</li> <li>Search through Examples</li> <li>Review the API Reference</li> <li>Raise an issue on our GitHub repository</li> </ol>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"api-reference/models/character/","title":"Character Model","text":"<p>The Character Model represents individual agents within the simulation, encapsulating their attributes, behaviors, and state management.</p>"},{"location":"api-reference/models/character/#overview","title":"Overview","text":"<p>Characters are the primary actors in the simulation, each with their own: - Personality traits - Memory and knowledge - Current state and behaviors - Relationships with other characters - Goals and motivations</p>"},{"location":"api-reference/models/character/#properties","title":"Properties","text":"<ul> <li><code>id</code>: Unique identifier for the character</li> <li><code>name</code>: Character's full name</li> <li><code>traits</code>: Dictionary of personality traits</li> <li><code>state</code>: Current state of the character</li> <li><code>memory</code>: Reference to the character's memory system</li> <li><code>relationships</code>: Dictionary of relationships with other characters</li> </ul>"},{"location":"api-reference/models/character/#methods","title":"Methods","text":""},{"location":"api-reference/models/character/#state-management","title":"State Management","text":"<pre><code>def update_state(self, new_state: str) -&gt; None\n</code></pre> <p>Updates the character's current state and triggers relevant state transition handlers.</p>"},{"location":"api-reference/models/character/#memory-management","title":"Memory Management","text":"<pre><code>def add_memory(self, memory_content: str, importance: float = 0.5) -&gt; None\n</code></pre> <p>Adds a new memory to the character's memory system with specified importance.</p>"},{"location":"api-reference/models/character/#usage-example","title":"Usage Example","text":"<p>```python character = Character(     name=\"John Smith\",     traits={         \"openness\": 0.7,         \"conscientiousness\": 0.8,         \"extraversion\": 0.6,         \"agreeableness\": 0.75,         \"neuroticism\": 0.4     } )</p> <p>character.update_state(\"working\") character.add_memory(\"Met Alice at the coffee shop\") </p>"},{"location":"core-concepts/building-system/","title":"Building System","text":"<p>The Building System manages all structures and locations within the simulation, handling building properties, equipment, jobs, and interactions with characters.</p>"},{"location":"core-concepts/building-system/#overview","title":"Overview","text":"<pre><code>graph TD\n    A[Building System] --&gt; B[Building Core]\n    A --&gt; C[Equipment System]\n    A --&gt; D[Job System]\n    B --&gt; E[Position Management]\n    B --&gt; F[State Management]\n    C --&gt; G[Equipment Status]\n    C --&gt; H[Equipment Functions]\n    D --&gt; I[Job Positions]\n    D --&gt; J[Applicant Management]\n</code></pre>"},{"location":"core-concepts/building-system/#core-components","title":"Core Components","text":""},{"location":"core-concepts/building-system/#building-model","title":"Building Model","text":"<p>The Building class inherits from SimsAgent, providing AI-powered interactions:</p> <pre><code>class Building:\n    def __init__(self, id, name, llm_cfg, xMin, yMin, xMax, yMax, \n                 description, instruction, equipments=None, \n                 jobs=None, money=0):\n        self.guid = id\n        self.name = name\n        self.money = money\n        self.position = (xMin, yMin, xMax, yMax)\n        self.equipments = {}  # Equipment dictionary\n        self.job_positions = {}  # Available jobs\n</code></pre>"},{"location":"core-concepts/building-system/#position-management","title":"Position Management","text":"<p>Buildings occupy specific coordinates on the map:</p> <pre><code>def cordinate_in_building(self, x, y):\n    return (self.xMin &lt;= x and x &lt;= self.xMax and \n            self.yMin &lt;= y and y &lt;= self.yMax)\n\n@property\ndef random_pos_inside(self):\n    # Returns random valid position within building\n    while True:\n        x = random.randint(self.xMin, self.xMax)\n        y = random.randint(self.yMin, self.yMax)\n        if self.map[x][y] == 1:\n            return (x, y)\n</code></pre>"},{"location":"core-concepts/building-system/#equipment-system","title":"Equipment System","text":""},{"location":"core-concepts/building-system/#equipment-model","title":"Equipment Model","text":"<pre><code>class InBuildingEquip:\n    def __init__(self, name, instruction, inbuilding=None, \n                 x=None, y=None, interactable=False, \n                 status=None, functions=None):\n        self.name = name\n        self.instruction = instruction\n        self.status = status\n        self.interactable = interactable\n        self.functions = self._setup_functions(functions)\n</code></pre> <p>Key features: - Equipment positioning within buildings - Interactable status tracking - Custom function registration - Status management</p>"},{"location":"core-concepts/building-system/#job-system","title":"Job System","text":""},{"location":"core-concepts/building-system/#job-management","title":"Job Management","text":"<pre><code>class Job:\n    def __init__(self, name, description, salary, \n                 inbuilding, num_positions):\n        self.name = name\n        self.description = description\n        self.salary = salary\n        self.inbuilding = inbuilding\n        self.applicants = []\n        self.num_positions = num_positions\n</code></pre> <p>Features: - Position tracking - Salary management - Applicant handling - Multiple position support</p>"},{"location":"core-concepts/building-system/#building-operations","title":"Building Operations","text":""},{"location":"core-concepts/building-system/#state-management","title":"State Management","text":"<p>Buildings maintain various states and properties:</p> <pre><code># Core building operations\ndef modify_internal_properties(self, prop):\n    for key, val in prop.items():\n        if key in self.modifiable_status:\n            setattr(prop, key, val)\n\ndef save_self_locally(self):\n    # Saves building state to disk\n    if self.save_dir:\n        dict2save = find_instance_specific_data_attrs(self)\n        # ... saving logic\n</code></pre>"},{"location":"core-concepts/building-system/#equipment-operations","title":"Equipment Operations","text":"<pre><code>def register_equip_functions(self, equipment):\n    if equipment.functions:\n        for func in equipment.functions:\n            self.register_callable_tools(func)\n\ndef equipment_instr(self, equip_name):\n    return f\"{self.equipments[equip_name].instruction} Current status: {self.equipments[equip_name].organize_status()}\"\n</code></pre>"},{"location":"core-concepts/building-system/#building-collections","title":"Building Collections","text":""},{"location":"core-concepts/building-system/#buildinglist-management","title":"BuildingList Management","text":"<pre><code>class BuildingList:\n    def __init__(self):\n        self.buildings = []\n\n    def get_building_by_pos(self, x, y):\n        for building in self.buildings:\n            if building.cordinate_in_building(x, y):\n                return building\n        return None\n</code></pre>"},{"location":"core-concepts/building-system/#best-practices","title":"Best Practices","text":"<ol> <li>Building Creation</li> <li>Always provide unique building IDs</li> <li>Set proper coordinate boundaries</li> <li> <p>Include clear descriptions and instructions</p> </li> <li> <p>Equipment Management</p> </li> <li>Register equipment functions properly</li> <li>Maintain equipment status</li> <li> <p>Handle equipment interactions carefully</p> </li> <li> <p>Job Management</p> </li> <li>Track position availability</li> <li>Manage applicants properly</li> <li> <p>Update salary information</p> </li> <li> <p>State Persistence</p> </li> <li>Regular state saves</li> <li>Proper serialization</li> <li>Version control for saved states</li> </ol>"},{"location":"core-concepts/building-system/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - Building Model API - Equipment API - Job System API </p>"},{"location":"core-concepts/character-system/","title":"Character System","text":"<p>The Character System is one of the core components of the Town Simulation Service. It manages the creation, behavior, and interactions of all characters within the town simulation.</p>"},{"location":"core-concepts/character-system/#character-model","title":"Character Model","text":"<pre><code>class Character:\n    def __init__(self, name, description, occupation, location):\n        self.name = name\n        self.description = description\n        self.occupation = occupation\n        self.location = location\n        self.state = None\n        self.memories = []\n        self.relationships = {}\n        self.schedule = []\n</code></pre>"},{"location":"core-concepts/character-system/#components","title":"Components","text":""},{"location":"core-concepts/character-system/#1-basic-attributes","title":"1. Basic Attributes","text":"<ul> <li>Name: Unique identifier for the character</li> <li>Description: Physical and personality traits</li> <li>Occupation: Character's role in the town</li> <li>Location: Current building or place</li> <li>State: Current activity or status</li> <li>Schedule: Daily routine and planned activities</li> </ul>"},{"location":"core-concepts/character-system/#2-memory-system","title":"2. Memory System","text":"<p>Characters maintain memories of: - Interactions with other characters - Events they've participated in - Experiences at locations - Important information learned - Emotional responses to situations</p> <pre><code># Adding a memory\ncharacter.add_memory(\n    content=\"Had a great conversation with Sarah at the cafe\",\n    importance=0.7,\n    related_entities=[\"Sarah\", \"Cafe\"],\n    emotion=\"happy\"\n)\n\n# Retrieving memories\nrelevant_memories = character.retrieve_memories(\n    query=\"What do I know about Sarah?\",\n    limit=5\n)\n</code></pre>"},{"location":"core-concepts/character-system/#3-relationship-system","title":"3. Relationship System","text":"<p>Characters maintain relationships with: - Other characters - Buildings they frequently visit - Organizations they belong to</p> <pre><code># Managing relationships\ncharacter.update_relationship(\n    target=\"Sarah\",\n    relationship_type=\"friend\",\n    strength=0.8\n)\n\n# Checking relationships\nfriends = character.get_relationships_by_type(\"friend\")\n</code></pre>"},{"location":"core-concepts/character-system/#4-state-management","title":"4. State Management","text":"<p>Characters can be in various states: - IDLE: Default state - BUSY: Engaged in an activity - INTERACTING: Talking with others - WORKING: Performing job duties - RESTING: Taking a break</p> <pre><code># State transitions\ncharacter.change_state(\"BUSY\")\nif character.can_interact():\n    character.change_state(\"INTERACTING\")\n</code></pre>"},{"location":"core-concepts/character-system/#behavior-system","title":"Behavior System","text":""},{"location":"core-concepts/character-system/#1-decision-making","title":"1. Decision Making","text":"<p>Characters make decisions based on: - Current state - Personal goals - Memories - Relationships - Environmental factors</p> <pre><code>decision = character.make_decision(\n    context=\"Should I visit the cafe?\",\n    options=[\"go_to_cafe\", \"stay_here\"],\n    factors=[\"time\", \"energy\", \"relationships\"]\n)\n</code></pre>"},{"location":"core-concepts/character-system/#2-interaction-system","title":"2. Interaction System","text":"<p>Characters can interact through: - Conversations - Activities - Trade - Relationships - Events</p> <pre><code># Basic interaction\nresponse = character.interact_with(\n    target=\"Sarah\",\n    action=\"greet\",\n    context=\"morning meeting\"\n)\n\n# Complex interaction\ninteraction = character.start_complex_interaction(\n    target=\"Sarah\",\n    interaction_type=\"business_meeting\",\n    duration=30,\n    location=\"Office\"\n)\n</code></pre>"},{"location":"core-concepts/character-system/#3-schedule-management","title":"3. Schedule Management","text":"<p>Characters follow daily routines: - Work schedules - Break times - Social activities - Personal tasks</p> <pre><code># Setting up a schedule\ncharacter.set_schedule([\n    {\n        \"time\": \"08:00\",\n        \"action\": \"start_work\",\n        \"location\": \"Office\",\n        \"duration\": 240\n    },\n    {\n        \"time\": \"12:00\",\n        \"action\": \"lunch_break\",\n        \"location\": \"Cafe\",\n        \"duration\": 60\n    }\n])\n\n# Checking schedule\nnext_activity = character.get_next_activity()\n</code></pre>"},{"location":"core-concepts/character-system/#integration-with-other-systems","title":"Integration with Other Systems","text":""},{"location":"core-concepts/character-system/#1-building-integration","title":"1. Building Integration","text":"<p>Characters interact with buildings: - Entering/leaving - Using facilities - Working - Living</p> <pre><code># Moving to a new location\ncharacter.move_to(building)\n\n# Interacting with building\ncharacter.use_building_facility(\n    building=\"Cafe\",\n    facility=\"Coffee Machine\"\n)\n</code></pre>"},{"location":"core-concepts/character-system/#2-event-integration","title":"2. Event Integration","text":"<p>Characters participate in events: - Town festivals - Work meetings - Social gatherings - Personal events</p> <pre><code># Joining an event\ncharacter.join_event(\n    event_name=\"Summer Festival\",\n    role=\"participant\"\n)\n\n# Creating an event\ncharacter.create_event(\n    name=\"Birthday Party\",\n    location=\"Home\",\n    invited_characters=[\"Sarah\", \"John\"]\n)\n</code></pre>"},{"location":"core-concepts/character-system/#3-memory-integration","title":"3. Memory Integration","text":"<p>Characters use memories for: - Decision making - Relationship building - Conversation context - Learning</p> <pre><code># Using memories in interaction\nrelevant_context = character.get_memory_context(\n    interaction_type=\"conversation\",\n    target=\"Sarah\"\n)\n\n# Learning from experiences\ncharacter.learn_from_interaction(\n    interaction_result=\"positive\",\n    target=\"Sarah\",\n    context=\"business deal\"\n)\n</code></pre>"},{"location":"core-concepts/character-system/#advanced-features","title":"Advanced Features","text":""},{"location":"core-concepts/character-system/#1-personality-traits","title":"1. Personality Traits","text":"<p>Characters have unique personalities: - Extroversion/Introversion - Agreeableness - Conscientiousness - Emotional stability - Openness</p>"},{"location":"core-concepts/character-system/#2-emotional-system","title":"2. Emotional System","text":"<p>Characters experience emotions: - Based on interactions - Affecting decisions - Influencing relationships - Changing over time</p>"},{"location":"core-concepts/character-system/#3-learning-system","title":"3. Learning System","text":"<p>Characters can learn and adapt: - New skills - Better decisions - Relationship preferences - Behavioral patterns</p>"},{"location":"core-concepts/character-system/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - Character Model API - Character State API - Memory System API</p>"},{"location":"core-concepts/character-system/#examples","title":"Examples","text":"<p>Check out our Examples section for: - Character creation - Interaction scenarios - Schedule management - Complex behaviors </p>"},{"location":"core-concepts/memory-system/","title":"Memory System","text":"<p>The Memory System is a sophisticated component that enables characters to store, retrieve, and utilize experiences and information in a human-like way. It uses vector embeddings and semantic search to create a realistic memory experience.</p>"},{"location":"core-concepts/memory-system/#overview","title":"Overview","text":"<pre><code>graph TD\n    A[Memory Input] --&gt; B[Memory Processing]\n    B --&gt; C[Vector Embedding]\n    C --&gt; D[Memory Storage]\n    D --&gt; E[Memory Retrieval]\n    E --&gt; F[Memory Application]\n    B --&gt; G[Importance Scoring]\n    G --&gt; D\n    D --&gt; H[Memory Consolidation]\n    H --&gt; D\n</code></pre>"},{"location":"core-concepts/memory-system/#core-components","title":"Core Components","text":""},{"location":"core-concepts/memory-system/#1-memory-model","title":"1. Memory Model","text":"<pre><code>class Memory:\n    def __init__(self, content, importance=0.5):\n        self.content = content\n        self.importance = importance\n        self.timestamp = current_time()\n        self.embedding = None\n        self.related_entities = []\n        self.emotions = {}\n        self.context = {}\n</code></pre>"},{"location":"core-concepts/memory-system/#2-memory-manager","title":"2. Memory Manager","text":"<pre><code>class MemoryManager:\n    def __init__(self, character):\n        self.character = character\n        self.short_term_memory = []\n        self.long_term_memory = []\n        self.memory_index = None\n        self.importance_threshold = 0.3\n\n    def add_memory(self, memory):\n        if memory.importance &gt;= self.importance_threshold:\n            self.process_and_store(memory)\n\n    def retrieve_memories(self, query, limit=5):\n        return self.semantic_search(query, limit)\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-types","title":"Memory Types","text":""},{"location":"core-concepts/memory-system/#1-short-term-memory","title":"1. Short-term Memory","text":"<p>Temporary storage for recent experiences: - High accessibility - Limited capacity - Temporary duration - Frequent updates</p> <pre><code>class ShortTermMemory:\n    def __init__(self, capacity=100):\n        self.memories = []\n        self.capacity = capacity\n\n    def add(self, memory):\n        if len(self.memories) &gt;= self.capacity:\n            self.consolidate_memories()\n        self.memories.append(memory)\n</code></pre>"},{"location":"core-concepts/memory-system/#2-long-term-memory","title":"2. Long-term Memory","text":"<p>Permanent storage for important information: - Persistent storage - Unlimited capacity - Organized structure - Importance-based retention</p> <pre><code>class LongTermMemory:\n    def __init__(self):\n        self.memories = {}\n        self.indexes = {}\n\n    def store(self, memory):\n        vector = self.embed_memory(memory)\n        self.memories[memory.id] = memory\n        self.indexes[memory.id] = vector\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-processing","title":"Memory Processing","text":""},{"location":"core-concepts/memory-system/#1-memory-creation","title":"1. Memory Creation","text":"<pre><code>def create_memory(content, context):\n    memory = Memory(content)\n    memory.importance = calculate_importance(content, context)\n    memory.embedding = generate_embedding(content)\n    memory.context = extract_context(context)\n    return memory\n\n# Example usage\nmemory = create_memory(\n    content=\"Met Sarah at the cafe\",\n    context={\n        \"location\": \"Town Cafe\",\n        \"time\": \"morning\",\n        \"emotion\": \"happy\"\n    }\n)\n</code></pre>"},{"location":"core-concepts/memory-system/#2-importance-scoring","title":"2. Importance Scoring","text":"<pre><code>def calculate_importance(content, context, factors):\n    score = 0.0\n\n    # Content-based scoring\n    score += analyze_content_significance(content)\n\n    # Context-based scoring\n    score += evaluate_context_importance(context)\n\n    # Emotional impact\n    score += measure_emotional_impact(factors.get('emotion'))\n\n    return normalize_score(score)\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-storage","title":"Memory Storage","text":""},{"location":"core-concepts/memory-system/#1-vector-database-integration","title":"1. Vector Database Integration","text":"<pre><code>class VectorStorage:\n    def __init__(self):\n        self.milvus_client = MilvusClient()\n        self.collection = None\n\n    def store_vector(self, memory_id, vector):\n        return self.milvus_client.insert(\n            collection_name=\"memories\",\n            vectors=[vector],\n            ids=[memory_id]\n        )\n</code></pre>"},{"location":"core-concepts/memory-system/#2-memory-indexing","title":"2. Memory Indexing","text":"<pre><code>class MemoryIndex:\n    def __init__(self):\n        self.index = {}\n        self.reverse_index = {}\n\n    def add_memory(self, memory):\n        # Index by time\n        self.index_by_time(memory)\n\n        # Index by entities\n        self.index_by_entities(memory)\n\n        # Index by emotions\n        self.index_by_emotions(memory)\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-retrieval","title":"Memory Retrieval","text":""},{"location":"core-concepts/memory-system/#1-semantic-search","title":"1. Semantic Search","text":"<pre><code>def semantic_search(query, memories, limit=5):\n    # Generate query embedding\n    query_vector = generate_embedding(query)\n\n    # Search in vector space\n    results = vector_storage.search(\n        collection_name=\"memories\",\n        query_vectors=[query_vector],\n        limit=limit\n    )\n\n    return process_search_results(results)\n</code></pre>"},{"location":"core-concepts/memory-system/#2-context-based-retrieval","title":"2. Context-based Retrieval","text":"<pre><code>def retrieve_by_context(context, limit=5):\n    relevant_memories = []\n\n    # Filter by location\n    if 'location' in context:\n        location_memories = find_memories_by_location(\n            context['location']\n        )\n        relevant_memories.extend(location_memories)\n\n    # Filter by time\n    if 'time' in context:\n        time_memories = find_memories_by_time(\n            context['time']\n        )\n        relevant_memories.extend(time_memories)\n\n    return rank_and_limit(relevant_memories, limit)\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-application","title":"Memory Application","text":""},{"location":"core-concepts/memory-system/#1-decision-making","title":"1. Decision Making","text":"<pre><code>def make_decision(situation, options):\n    # Retrieve relevant memories\n    memories = retrieve_relevant_memories(situation)\n\n    # Analyze past experiences\n    experiences = analyze_memories(memories)\n\n    # Apply memory-based reasoning\n    decision = reason_from_experiences(\n        experiences,\n        options\n    )\n\n    return decision\n</code></pre>"},{"location":"core-concepts/memory-system/#2-conversation-context","title":"2. Conversation Context","text":"<pre><code>def get_conversation_context(target, topic):\n    # Get relevant memories about target\n    target_memories = retrieve_memories_about(target)\n\n    # Get topic-related memories\n    topic_memories = retrieve_memories_about(topic)\n\n    # Combine and process memories\n    context = create_conversation_context(\n        target_memories,\n        topic_memories\n    )\n\n    return context\n</code></pre>"},{"location":"core-concepts/memory-system/#memory-maintenance","title":"Memory Maintenance","text":""},{"location":"core-concepts/memory-system/#1-memory-consolidation","title":"1. Memory Consolidation","text":"<pre><code>def consolidate_memories():\n    # Get short-term memories\n    recent_memories = get_short_term_memories()\n\n    # Group related memories\n    memory_groups = group_related_memories(recent_memories)\n\n    # Create consolidated memories\n    for group in memory_groups:\n        consolidated = create_consolidated_memory(group)\n        store_in_long_term_memory(consolidated)\n</code></pre>"},{"location":"core-concepts/memory-system/#2-memory-decay","title":"2. Memory Decay","text":"<pre><code>def apply_memory_decay():\n    for memory in all_memories:\n        # Calculate time factor\n        age = current_time() - memory.timestamp\n        decay_factor = calculate_decay_factor(age)\n\n        # Update importance\n        memory.importance *= decay_factor\n\n        # Archive or remove if below threshold\n        if memory.importance &lt; min_importance:\n            archive_memory(memory)\n</code></pre>"},{"location":"core-concepts/memory-system/#integration-examples","title":"Integration Examples","text":""},{"location":"core-concepts/memory-system/#1-basic-memory-usage","title":"1. Basic Memory Usage","text":"<pre><code># Adding a memory\ncharacter.add_memory(\n    content=\"Had coffee with Bob\",\n    importance=0.7,\n    context={\n        \"location\": \"Cafe\",\n        \"time\": \"morning\",\n        \"emotion\": \"happy\"\n    }\n)\n\n# Retrieving memories\nmemories = character.retrieve_memories(\n    query=\"What do I know about Bob?\",\n    limit=5\n)\n</code></pre>"},{"location":"core-concepts/memory-system/#2-memory-based-interaction","title":"2. Memory-based Interaction","text":"<pre><code>def handle_interaction(target, context):\n    # Get relevant memories\n    memories = retrieve_memories_about(target)\n\n    # Process memories for context\n    interaction_context = process_memories_for_interaction(\n        memories,\n        context\n    )\n\n    # Generate response\n    response = generate_response_with_context(\n        interaction_context\n    )\n\n    return response\n</code></pre>"},{"location":"core-concepts/memory-system/#best-practices","title":"Best Practices","text":"<ol> <li>Memory Creation</li> <li>Include relevant context</li> <li>Set appropriate importance</li> <li>Add emotional content</li> <li> <p>Tag related entities</p> </li> <li> <p>Memory Retrieval</p> </li> <li>Use specific queries</li> <li>Consider context</li> <li>Limit result size</li> <li> <p>Handle missing memories</p> </li> <li> <p>Memory Maintenance</p> </li> <li>Regular consolidation</li> <li>Proper decay rules</li> <li>Importance thresholds</li> <li>Backup strategies</li> </ol>"},{"location":"core-concepts/memory-system/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - Memory Model API - Memory Manager API - Vector Storage API </p>"},{"location":"core-concepts/overview/","title":"Core Concepts Overview","text":"<p>The Town Simulation Service is built around several key concepts that work together to create a dynamic and interactive virtual town environment. This overview will introduce you to these core concepts and how they interact with each other.</p>"},{"location":"core-concepts/overview/#system-architecture","title":"System Architecture","text":"<pre><code>flowchart TD\n    Start[Start Simulation] --&gt; Init[Initialize Simulation]\n    Init --&gt; LoadData[Load Frontend/Backend Data]\n    LoadData --&gt; CreateManagers[Create Character State Managers]\n\n    CreateManagers --&gt; UpdateLoop[Update Loop]\n\n    UpdateLoop --&gt; HandleMsg{Handle Server Messages}\n    HandleMsg --&gt;|New Day| ResetCountdown[Reset Newday Countdown]\n    HandleMsg --&gt;|Other Messages| FilterMsg[Filter Messages by State]\n\n    ResetCountdown --&gt; UpdateStates\n    FilterMsg --&gt; UpdateStates[Update Character States]\n\n    UpdateStates --&gt; StateChains[Execute State Chains]\n\n    StateChains --&gt; EnterChain[Enter State Chain]\n    StateChains --&gt; ExitChain[Exit State Chain]\n    StateChains --&gt; UpdateChain[Update State Chain]\n    StateChains --&gt; PostLLMChain[Post LLM Chain]\n\n    EnterChain --&gt; |Functions|BuildPrompt[Build Prompt]\n    BuildPrompt --&gt; CallLLM[Call LLM]\n\n    CallLLM --&gt; ProcessResponse[Process LLM Response]\n    ProcessResponse --&gt; StateRouter{State Router}\n\n    StateRouter --&gt;|Change State| NextState[Change to Next State]\n    StateRouter --&gt;|Stay| UpdateLoop\n\n    NextState --&gt; UpdateLoop\n\n    UpdateLoop --&gt; |Continue|HandleMsg\n    UpdateLoop --&gt; |End|End[End Simulation]\n\n    subgraph \"State Functions\"\n        EnterChain\n        ExitChain\n        UpdateChain\n        PostLLMChain\n    end\n\n    subgraph \"LLM Processing\"\n        BuildPrompt\n        CallLLM\n        ProcessResponse\n    end\n</code></pre>"},{"location":"core-concepts/overview/#key-components","title":"Key Components","text":""},{"location":"core-concepts/overview/#1-simulation","title":"1. Simulation","text":"<p>The Simulation is the main container and orchestrator of the simulation. It: - Manages all characters and buildings - Coordinates events and interactions - Maintains the simulation state - Handles time progression - Manages global resources</p>"},{"location":"core-concepts/overview/#2-characters","title":"2. Characters","text":"<p>Characters are the intelligent agents within the simulation. They: - Have personalities and traits - Maintain relationships with other characters - Follow daily routines and schedules - Interact with other characters and buildings - Store and retrieve memories - Change states based on activities</p>"},{"location":"core-concepts/overview/#3-buildings","title":"3. Buildings","text":"<p>Buildings are locations within the simulation where: - Characters can be located - Activities take place - Events can be hosted - Resources can be stored - Services can be provided</p>"},{"location":"core-concepts/overview/#4-state-management","title":"4. State Management","text":"<p>The state system: - Controls character behavior - Manages transitions between activities - Handles interruptions and priorities - Ensures realistic behavior patterns - Coordinates multi-character interactions</p>"},{"location":"core-concepts/overview/#5-memory-system","title":"5. Memory System","text":"<p>The memory system allows characters to: - Store experiences and information - Retrieve relevant memories - Influence decision making - Build relationships over time - Learn from past interactions</p>"},{"location":"core-concepts/overview/#component-interactions","title":"Component Interactions","text":""},{"location":"core-concepts/overview/#character-building-interaction","title":"Character-Building Interaction","text":"<pre><code>sequenceDiagram\n    participant C as Character\n    participant B as Building\n    participant S as Simulation\n\n    C-&gt;&gt;S: Request location change\n    S-&gt;&gt;B: Check availability\n    B-&gt;&gt;S: Confirm space\n    S-&gt;&gt;C: Update location\n    C-&gt;&gt;B: Perform activity\n</code></pre>"},{"location":"core-concepts/overview/#character-character-interaction","title":"Character-Character Interaction","text":"<pre><code>sequenceDiagram\n    participant C1 as Character 1\n    participant SM as State Manager\n    participant C2 as Character 2\n\n    C1-&gt;&gt;SM: Request interaction\n    SM-&gt;&gt;C2: Check availability\n    C2-&gt;&gt;SM: Confirm state\n    SM-&gt;&gt;C1: Enable interaction\n    C1-&gt;&gt;C2: Interact\n</code></pre>"},{"location":"core-concepts/overview/#memory-state-interaction","title":"Memory-State Interaction","text":"<pre><code>sequenceDiagram\n    participant C as Character\n    participant M as Memory System\n    participant S as State Manager\n\n    C-&gt;&gt;S: Current situation\n    S-&gt;&gt;M: Request relevant memories\n    M-&gt;&gt;S: Provide context\n    S-&gt;&gt;C: Determine action\n</code></pre>"},{"location":"core-concepts/overview/#system-flow","title":"System Flow","text":"<ol> <li>Initialization</li> <li>Town creation</li> <li>Character and building setup</li> <li>State system initialization</li> <li> <p>Memory system preparation</p> </li> <li> <p>Runtime</p> </li> <li>Time progression</li> <li>State updates</li> <li>Interaction processing</li> <li>Memory management</li> <li> <p>Event handling</p> </li> <li> <p>Interaction Processing</p> </li> <li>State checking</li> <li>Memory retrieval</li> <li>Action determination</li> <li>Response generation</li> <li>Memory storage</li> </ol>"},{"location":"core-concepts/overview/#integration-points","title":"Integration Points","text":""},{"location":"core-concepts/overview/#1-llm-integration","title":"1. LLM Integration","text":"<p>The system integrates with Large Language Models for: - Natural language processing - Decision making - Response generation - Memory summarization - Personality expression</p>"},{"location":"core-concepts/overview/#2-database-integration","title":"2. Database Integration","text":"<p>Persistent storage is used for: - Character data - Memory vectors - Relationship graphs - State history - Event logs</p>"},{"location":"core-concepts/overview/#3-external-services","title":"3. External Services","text":"<p>The system can connect with: - WebSocket for real-time updates - Redis for caching - Milvus for vector search - Custom APIs for extended functionality</p>"},{"location":"core-concepts/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about the Character System</li> <li>Explore State Management</li> <li>Understand the Memory System</li> <li>Study the Building System</li> <li>Dive into Simulation Logic </li> </ul>"},{"location":"core-concepts/simulation-logic/","title":"Simulation Logic","text":"<p>The Simulation Logic system is the core engine that drives the Town Simulation Service. It manages time progression, event scheduling, character behaviors, and the overall simulation state.</p>"},{"location":"core-concepts/simulation-logic/#overview","title":"Overview","text":"<pre><code>graph TD\n    A[Simulation Engine] --&gt; B[Time Management]\n    A --&gt; C[Event System]\n    A --&gt; D[Character Management]\n    A --&gt; E[World State]\n    B --&gt; F[Time Progression]\n    B --&gt; G[Schedules]\n    C --&gt; H[Event Queue]\n    C --&gt; I[Event Processing]\n    D --&gt; J[Behavior Updates]\n    D --&gt; K[Interaction Processing]\n    E --&gt; L[State Tracking]\n    E --&gt; M[Resource Management]\n</code></pre>"},{"location":"core-concepts/simulation-logic/#core-components","title":"Core Components","text":""},{"location":"core-concepts/simulation-logic/#1-simulation-engine","title":"1. Simulation Engine","text":"<pre><code>class SimulationEngine:\n    def __init__(self):\n        self.time_manager = TimeManager()\n        self.event_system = EventSystem()\n        self.character_manager = CharacterManager()\n        self.world_state = WorldState()\n        self.is_running = False\n\n    def start_simulation(self):\n        self.is_running = True\n        self.main_loop()\n\n    def main_loop(self):\n        while self.is_running:\n            self.update()\n            self.process_events()\n            self.update_characters()\n            self.time_manager.advance_time()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-time-management","title":"2. Time Management","text":"<pre><code>class TimeManager:\n    def __init__(self):\n        self.current_time = 0\n        self.time_scale = 1.0\n        self.tick_rate = 60\n\n    def advance_time(self):\n        delta = 1.0 / self.tick_rate * self.time_scale\n        self.current_time += delta\n        self.update_scheduled_events()\n\n    def set_time_scale(self, scale):\n        self.time_scale = max(0.1, min(10.0, scale))\n</code></pre>"},{"location":"core-concepts/simulation-logic/#event-system","title":"Event System","text":""},{"location":"core-concepts/simulation-logic/#1-event-queue","title":"1. Event Queue","text":"<pre><code>class EventQueue:\n    def __init__(self):\n        self.events = []\n        self.processed_events = []\n\n    def add_event(self, event):\n        heapq.heappush(self.events, (event.time, event))\n\n    def process_next_event(self):\n        if self.events:\n            time, event = heapq.heappop(self.events)\n            if time &lt;= current_time():\n                self.process_event(event)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-event-types","title":"2. Event Types","text":"<pre><code>class SimulationEvent:\n    def __init__(self, event_type, time, data):\n        self.type = event_type\n        self.time = time\n        self.data = data\n        self.processed = False\n\n    def process(self):\n        if self.type == \"CHARACTER_INTERACTION\":\n            self.process_character_interaction()\n        elif self.type == \"SCHEDULED_EVENT\":\n            self.process_scheduled_event()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#character-management","title":"Character Management","text":""},{"location":"core-concepts/simulation-logic/#1-behavior-processing","title":"1. Behavior Processing","text":"<pre><code>class BehaviorProcessor:\n    def update_characters(self, characters):\n        for character in characters:\n            self.process_character_behavior(character)\n\n    def process_character_behavior(self, character):\n        # Update state\n        character.update_state()\n\n        # Process needs\n        character.process_needs()\n\n        # Handle interactions\n        character.process_interactions()\n\n        # Update location\n        character.update_location()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-interaction-system","title":"2. Interaction System","text":"<pre><code>class InteractionSystem:\n    def process_interaction(self, source, target, type):\n        if self.can_interact(source, target):\n            interaction = self.create_interaction(\n                source, target, type\n            )\n            return self.execute_interaction(interaction)\n        return False\n</code></pre>"},{"location":"core-concepts/simulation-logic/#world-state-management","title":"World State Management","text":""},{"location":"core-concepts/simulation-logic/#1-state-tracking","title":"1. State Tracking","text":"<pre><code>class WorldState:\n    def __init__(self):\n        self.characters = {}\n        self.buildings = {}\n        self.events = {}\n        self.resources = {}\n\n    def update(self):\n        self.update_characters()\n        self.update_buildings()\n        self.update_resources()\n        self.check_event_triggers()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-resource-management","title":"2. Resource Management","text":"<pre><code>class ResourceManager:\n    def __init__(self):\n        self.resources = {}\n        self.consumers = {}\n        self.producers = {}\n\n    def update_resources(self):\n        self.process_production()\n        self.process_consumption()\n        self.balance_resources()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#time-based-features","title":"Time-Based Features","text":""},{"location":"core-concepts/simulation-logic/#1-schedule-management","title":"1. Schedule Management","text":"<pre><code>class ScheduleManager:\n    def __init__(self):\n        self.schedules = {}\n        self.active_tasks = {}\n\n    def add_schedule(self, entity, schedule):\n        self.schedules[entity.id] = schedule\n\n    def update_schedules(self):\n        current_time = self.get_current_time()\n        for entity_id, schedule in self.schedules.items():\n            self.process_schedule(entity_id, schedule, current_time)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-time-based-events","title":"2. Time-Based Events","text":"<pre><code>class TimeBasedEvent:\n    def __init__(self, trigger_time, event_type, data):\n        self.trigger_time = trigger_time\n        self.event_type = event_type\n        self.data = data\n        self.recurring = False\n\n    def should_trigger(self, current_time):\n        return current_time &gt;= self.trigger_time\n</code></pre>"},{"location":"core-concepts/simulation-logic/#integration-examples","title":"Integration Examples","text":""},{"location":"core-concepts/simulation-logic/#1-basic-simulation-setup","title":"1. Basic Simulation Setup","text":"<pre><code># Initialize simulation\nsimulation = SimulationEngine()\n\n# Add characters\nsimulation.add_character(\n    Character(\"Alice\", \"Shop Owner\")\n)\nsimulation.add_character(\n    Character(\"Bob\", \"Customer\")\n)\n\n# Add buildings\nsimulation.add_building(\n    Building(\"Shop\", \"Commercial\")\n)\n\n# Start simulation\nsimulation.start()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-event-handling","title":"2. Event Handling","text":"<pre><code># Creating and processing events\ndef handle_character_meeting():\n    event = SimulationEvent(\n        event_type=\"CHARACTER_MEETING\",\n        time=current_time() + 3600,\n        data={\n            \"characters\": [\"Alice\", \"Bob\"],\n            \"location\": \"Shop\",\n            \"duration\": 1800\n        }\n    )\n    simulation.event_system.add_event(event)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#advanced-features","title":"Advanced Features","text":""},{"location":"core-concepts/simulation-logic/#1-simulation-controls","title":"1. Simulation Controls","text":"<pre><code>class SimulationControls:\n    def pause_simulation(self):\n        self.is_running = False\n        self.save_state()\n\n    def resume_simulation(self):\n        self.load_state()\n        self.is_running = True\n\n    def set_simulation_speed(self, speed):\n        self.time_manager.set_time_scale(speed)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-state-persistence","title":"2. State Persistence","text":"<pre><code>class StatePersistence:\n    def save_state(self):\n        state = {\n            'time': self.current_time,\n            'characters': self.serialize_characters(),\n            'buildings': self.serialize_buildings(),\n            'events': self.serialize_events()\n        }\n        return self.store_state(state)\n\n    def load_state(self, state_id):\n        state = self.retrieve_state(state_id)\n        self.restore_simulation(state)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#performance-optimization","title":"Performance Optimization","text":""},{"location":"core-concepts/simulation-logic/#1-update-scheduling","title":"1. Update Scheduling","text":"<pre><code>class UpdateScheduler:\n    def __init__(self):\n        self.update_frequency = {\n            'characters': 1,    # Every tick\n            'buildings': 5,     # Every 5 ticks\n            'resources': 10,    # Every 10 ticks\n            'events': 1         # Every tick\n        }\n\n    def should_update(self, component, tick):\n        return tick % self.update_frequency[component] == 0\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-spatial-partitioning","title":"2. Spatial Partitioning","text":"<pre><code>class SpatialManager:\n    def __init__(self, world_size, partition_size):\n        self.partitions = {}\n        self.setup_partitions(world_size, partition_size)\n\n    def update_entity_position(self, entity):\n        old_partition = self.get_entity_partition(entity)\n        new_partition = self.calculate_partition(entity.position)\n        self.move_entity(entity, old_partition, new_partition)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#best-practices","title":"Best Practices","text":"<ol> <li>Simulation Management</li> <li>Regular state saves</li> <li>Performance monitoring</li> <li>Error handling</li> <li> <p>Load balancing</p> </li> <li> <p>Event Processing</p> </li> <li>Priority handling</li> <li>Event validation</li> <li>Error recovery</li> <li> <p>Event logging</p> </li> <li> <p>Time Management</p> </li> <li>Consistent time steps</li> <li>Time scale limits</li> <li>Schedule validation</li> <li>Time synchronization</li> </ol>"},{"location":"core-concepts/simulation-logic/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"core-concepts/simulation-logic/#1-performance-issues","title":"1. Performance Issues","text":"<p>Problem: Simulation slowdown Solution:</p> <pre><code>def optimize_performance():\n    # Implement spatial partitioning\n    spatial_manager = SpatialManager(world_size, partition_size)\n\n    # Use update scheduling\n    update_scheduler = UpdateScheduler()\n\n    # Batch processing\n    batch_processor = BatchProcessor(batch_size=100)\n</code></pre>"},{"location":"core-concepts/simulation-logic/#2-state-consistency","title":"2. State Consistency","text":"<p>Problem: Inconsistent simulation state Solution:</p> <pre><code>def maintain_state_consistency():\n    # Regular state validation\n    state_validator = StateValidator()\n\n    # Automatic state correction\n    state_corrector = StateCorrector()\n\n    # State logging\n    state_logger = StateLogger()\n</code></pre>"},{"location":"core-concepts/simulation-logic/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - Simulation Engine API - Event System API - Time Management API </p>"},{"location":"core-concepts/state-management/","title":"State Management","text":"<p>The State Management system is a crucial component of the Town Simulation Service that controls character behaviors, activities, and interactions through a sophisticated state machine implementation.</p>"},{"location":"core-concepts/state-management/#overview","title":"Overview","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; IDLE\n    IDLE --&gt; BUSY\n    IDLE --&gt; INTERACTING\n    BUSY --&gt; IDLE\n    BUSY --&gt; INTERACTING\n    INTERACTING --&gt; IDLE\n    INTERACTING --&gt; BUSY\n    IDLE --&gt; WORKING\n    WORKING --&gt; IDLE\n    WORKING --&gt; INTERACTING\n    IDLE --&gt; RESTING\n    RESTING --&gt; IDLE\n</code></pre>"},{"location":"core-concepts/state-management/#state-types","title":"State Types","text":""},{"location":"core-concepts/state-management/#1-base-states","title":"1. Base States","text":"<pre><code>from enum import Enum\n\nclass CharacterState(Enum):\n    IDLE = auto()\n    MOVE = auto()\n    SLEEPING = auto()\n    PLAN = auto()\n    ACT = auto()\n    PERSP = auto()\n    PERSPQ = auto()\n    PERSPA = auto()\n    CRITIC = auto()\n    CHATINIT = auto()\n    CHATING = auto()\n    ACTREFLECTION = auto()\n</code></pre>"},{"location":"core-concepts/state-management/#2-composite-states","title":"2. Composite States","text":"<p>States can be combined with modifiers: - Primary state: Main activity - Secondary state: Additional context - Temporary state: Short-term condition</p> <pre><code>character.set_composite_state(\n    primary=\"WORKING\",\n    secondary=\"INTERACTING\",\n    temporary=\"STRESSED\"\n)\n</code></pre>"},{"location":"core-concepts/state-management/#state-manager","title":"State Manager","text":""},{"location":"core-concepts/state-management/#1-basic-operations","title":"1. Basic Operations","text":"<pre><code>class StateManager:\n    def __init__(self, character):\n        self.character = character\n        self.current_state = None\n        self.state_history = []\n        self.state_transitions = {}\n\n    def change_state(self, new_state):\n        if self.can_transition_to(new_state):\n            self.exit_current_state()\n            self.enter_new_state(new_state)\n\n    def can_transition_to(self, new_state):\n        return new_state in self.state_transitions.get(\n            self.current_state, []\n        )\n</code></pre>"},{"location":"core-concepts/state-management/#2-state-lifecycle","title":"2. State Lifecycle","text":"<p>Each state has three main phases: 1. Enter: Initial setup and validation 2. Update: Regular state maintenance 3. Exit: Cleanup and transition preparation</p> <pre><code>class BaseState:\n    def enter_state(self):\n        \"\"\"Called when entering the state\"\"\"\n        pass\n\n    def update_state(self):\n        \"\"\"Called every update cycle\"\"\"\n        pass\n\n    def exit_state(self):\n        \"\"\"Called when exiting the state\"\"\"\n        pass\n</code></pre>"},{"location":"core-concepts/state-management/#state-implementation","title":"State Implementation","text":""},{"location":"core-concepts/state-management/#1-idle-state","title":"1. Idle State","text":"<pre><code>class IdleState(BaseState):\n    def enter_state(self):\n        self.character.reset_activity()\n        self.character.look_for_activities()\n\n    def update_state(self):\n        if self.character.has_pending_activities():\n            self.change_state(\"BUSY\")\n\n    def exit_state(self):\n        self.character.prepare_for_activity()\n</code></pre>"},{"location":"core-concepts/state-management/#2-working-state","title":"2. Working State","text":"<pre><code>class WorkingState(BaseState):\n    def enter_state(self):\n        self.character.start_work_routine()\n        self.set_work_schedule()\n\n    def update_state(self):\n        self.character.perform_work_tasks()\n        if self.is_work_complete():\n            self.change_state(\"IDLE\")\n\n    def exit_state(self):\n        self.character.complete_work_tasks()\n</code></pre>"},{"location":"core-concepts/state-management/#state-transitions","title":"State Transitions","text":""},{"location":"core-concepts/state-management/#1-transition-rules","title":"1. Transition Rules","text":"<pre><code>class StateTransitionRules:\n    def __init__(self):\n        self.transitions = {\n            \"IDLE\": [\"BUSY\", \"INTERACTING\", \"WORKING\", \"RESTING\"],\n            \"BUSY\": [\"IDLE\", \"INTERACTING\"],\n            \"WORKING\": [\"IDLE\", \"INTERACTING\"],\n            \"INTERACTING\": [\"IDLE\", \"BUSY\", \"WORKING\"],\n            \"RESTING\": [\"IDLE\"]\n        }\n\n    def can_transition(self, from_state, to_state):\n        return to_state in self.transitions.get(from_state, [])\n</code></pre>"},{"location":"core-concepts/state-management/#2-transition-conditions","title":"2. Transition Conditions","text":"<pre><code>class TransitionCondition:\n    def __init__(self, from_state, to_state, conditions):\n        self.from_state = from_state\n        self.to_state = to_state\n        self.conditions = conditions\n\n    def check_conditions(self, character):\n        return all(\n            condition(character) \n            for condition in self.conditions\n        )\n</code></pre>"},{"location":"core-concepts/state-management/#state-behaviors","title":"State Behaviors","text":""},{"location":"core-concepts/state-management/#1-activity-management","title":"1. Activity Management","text":"<pre><code>class StateBehavior:\n    def handle_interaction(self, target):\n        if self.can_interact():\n            return self.start_interaction(target)\n        return False\n\n    def handle_interruption(self, priority):\n        if self.can_be_interrupted(priority):\n            self.pause_current_activity()\n            return True\n        return False\n</code></pre>"},{"location":"core-concepts/state-management/#2-time-management","title":"2. Time Management","text":"<pre><code>class TimeAwareState:\n    def __init__(self, duration=None):\n        self.start_time = None\n        self.duration = duration\n\n    def is_expired(self):\n        if not self.duration:\n            return False\n        return (current_time() - self.start_time) &gt;= self.duration\n</code></pre>"},{"location":"core-concepts/state-management/#integration-examples","title":"Integration Examples","text":""},{"location":"core-concepts/state-management/#1-basic-state-change","title":"1. Basic State Change","text":"<pre><code># Simple state transition\ncharacter.change_state(\"WORKING\")\n\n# Conditional state change\nif character.is_tired():\n    character.change_state(\"RESTING\")\n</code></pre>"},{"location":"core-concepts/state-management/#2-complex-state-management","title":"2. Complex State Management","text":"<pre><code># Managing work schedule\ncharacter.state_manager.schedule_state_change(\n    new_state=\"WORKING\",\n    start_time=\"09:00\",\n    duration=480  # 8 hours\n)\n\n# Handling interruptions\ncharacter.state_manager.handle_interruption(\n    new_state=\"INTERACTING\",\n    priority=\"HIGH\",\n    duration=15\n)\n</code></pre>"},{"location":"core-concepts/state-management/#3-state-based-behavior","title":"3. State-based Behavior","text":"<pre><code># State-specific actions\nif character.current_state == \"WORKING\":\n    character.perform_work_tasks()\nelif character.current_state == \"RESTING\":\n    character.recover_energy()\n</code></pre>"},{"location":"core-concepts/state-management/#advanced-features","title":"Advanced Features","text":""},{"location":"core-concepts/state-management/#1-state-priorities","title":"1. State Priorities","text":"<p>States can have different priority levels: - CRITICAL: Must be handled immediately - HIGH: Important but can wait - NORMAL: Regular activities - LOW: Can be interrupted</p>"},{"location":"core-concepts/state-management/#2-state-queuing","title":"2. State Queuing","text":"<pre><code>class StateQueue:\n    def add_state(self, state, priority):\n        self.queue.put((priority, state))\n\n    def process_next_state(self):\n        if not self.queue.empty():\n            priority, state = self.queue.get()\n            self.change_state(state)\n</code></pre>"},{"location":"core-concepts/state-management/#3-state-history","title":"3. State History","text":"<pre><code>class StateHistory:\n    def add_state_change(self, from_state, to_state):\n        self.history.append({\n            'from': from_state,\n            'to': to_state,\n            'time': current_time()\n        })\n\n    def get_recent_states(self, limit=5):\n        return self.history[-limit:]\n</code></pre>"},{"location":"core-concepts/state-management/#best-practices","title":"Best Practices","text":"<ol> <li>State Validation</li> <li>Always check if state transition is valid</li> <li>Validate state conditions before changing</li> <li> <p>Handle invalid state transitions gracefully</p> </li> <li> <p>State Duration</p> </li> <li>Set appropriate timeouts for states</li> <li>Handle state expiration properly</li> <li> <p>Consider state interruptions</p> </li> <li> <p>State Cleanup</p> </li> <li>Always cleanup resources in exit_state</li> <li>Handle incomplete activities</li> <li>Update character status properly</li> </ol>"},{"location":"core-concepts/state-management/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"core-concepts/state-management/#1-state-lock","title":"1. State Lock","text":"<p>Problem: Character stuck in a state Solution:</p> <pre><code>def force_state_reset(character):\n    character.exit_current_state(force=True)\n    character.change_state(\"IDLE\")\n</code></pre>"},{"location":"core-concepts/state-management/#2-invalid-transitions","title":"2. Invalid Transitions","text":"<p>Problem: Illegal state transitions Solution:</p> <pre><code>def safe_state_change(character, new_state):\n    if character.can_transition_to(new_state):\n        character.change_state(new_state)\n    else:\n        character.queue_state_change(new_state)\n</code></pre>"},{"location":"core-concepts/state-management/#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see: - State Manager API - State Implementation - Transition Rules</p>"},{"location":"core-concepts/state-management/#related-guides","title":"Related Guides","text":"<ul> <li>How to Add a New State </li> </ul>"},{"location":"examples/add_new_state/","title":"Steps to Add a New Character State","text":""},{"location":"examples/add_new_state/#basic-concepts","title":"Basic Concepts","text":"<p>Each state contains three main lifecycle methods:</p> <ol> <li><code>enter_state</code>: Executed when entering the state</li> <li><code>update_state</code>: Executed when updating the state</li> <li><code>exit_state</code>: Executed when exiting the state</li> </ol>"},{"location":"examples/add_new_state/#state-lifecycle-example","title":"State Lifecycle Example","text":"<pre><code>from app.service.character_state.base_state import BaseState\nfrom app.constants.prompt_type import PromptType\nfrom app.constants.character_state import CharacterState\n\nclass ExampleState(BaseState):\n    def __init__(self, character, character_list, building_list, on_change_state):\n        # Configure basic state properties\n        super().__init__(\n            character=character,\n            main_prompt=PromptType.EXAMPLE,  # Define the main prompt type used by the state\n            character_list=character_list,\n            building_list=building_list,\n            followed_states=[CharacterState.IDLE],  # Define subsequent states that can be transitioned to\n            on_change_state=on_change_state,\n            state_name=CharacterState.EXAMPLE  # State name\n        )\n\n    def enter_state(self, **kwargs):\n        \"\"\"Operations executed when entering the state\"\"\"\n        # Call parent class enter_state method\n        super().enter_state(**kwargs)\n        # Add specific entry logic here\n        print(f\"{self.character.name} entered example state\")\n\n    def update_state(self, msg, date, **kwargs):\n        \"\"\"Operations executed when updating the state\"\"\"\n        # Call parent class update_state method\n        return_dict = super().update_state(msg, date, **kwargs)\n        # Add specific update logic here\n        return return_dict\n\n    def exit_state(self, **kwargs):\n        \"\"\"Operations executed when exiting the state\"\"\"\n        # Call parent class exit_state method\n        success, msg = super().exit_state(**kwargs)\n        # Add specific exit logic here\n        return success, msg\n</code></pre>"},{"location":"examples/add_new_state/#adding-a-new-prompt","title":"Adding a New Prompt","text":"<p>Each state typically needs a corresponding Prompt class to handle LLM interactions. Here's an example of creating a new Prompt: BasePrompt.recordable_key will be automatically stored into working memory, a dict storing values for further state processing. </p> <pre><code>from app.llm.prompt.base_prompt import BasePrompt\n\nclass ExamplePrompt(BasePrompt):\n    # Define prompt template\n    PROMPT = '''\n    Current Character: {character_name}\n    Current Location: {location}\n\n    Please make a decision based on the following information:\n    {context}\n\n    Please return your decision in JSON format:\n    {\n        \"decision\": \"your decision\",\n        \"reason\": \"reason for decision\"\n    }\n    '''\n\n    def __init__(self, prompt_type, state):\n        super().__init__(prompt_type, state)\n        # Set keys to be recorded in working memory\n        self.recordable_key = [\"decision\", \"reason\"]\n\n    def create_prompt(self):\n        \"\"\"Create complete prompt\"\"\"\n        # Add specific prompt processing logic here\n        return self.format_attr(\n            character_name=self.character.name,\n            location=self.character.in_building_name,\n            context=\"Context information goes here\"\n        )\n</code></pre>"},{"location":"examples/add_new_state/#complete-steps","title":"Complete Steps","text":"<ol> <li>Define New Prompt Type</li> </ol> <pre><code># app/constants/prompt_type.py\nclass PromptType(Enum):\n    # ... other prompt types ...\n    EXAMPLE = auto()\n</code></pre> <ol> <li>Create New State Type</li> </ol> <pre><code># app/constants/character_state.py\nclass CharacterState(Enum):\n    # ... other states ...\n    EXAMPLE = auto()\n</code></pre> <ol> <li>Register New State</li> </ol> <pre><code># app/service/character_state/__init__.py\nfrom .example_state import ExampleState\n</code></pre> <pre><code># app/service/character_state/state_factory.py\nfrom .example_state import ExampleState\n\ndef get_initialized_states(character, change_state_callback):\n    return {\n        # ... other states ...\n        CharacterState.EXAMPLE: ExampleState(\n            character,\n            character_list,\n            building_list,\n            change_state_callback\n        ),\n    }\n</code></pre> <ol> <li>Register Prompt Class</li> </ol> <pre><code># app/service/character_state/__init__.py\nfrom .example_prompt import ExamplePrompt\n\nPromptName2Registered = {\n    # ... other prompts ...\n    PromptType.EXAMPLE: ExamplePrompt,\n}\n</code></pre>"},{"location":"examples/add_new_state/#important-notes","title":"Important Notes","text":"<ol> <li>Ensure new states include appropriate <code>followed_states</code></li> <li>Set <code>recordable_key</code> when creating Prompt class</li> <li>State transition logic should be implemented in <code>update_state</code></li> <li>Use <code>self.turn_on_states()</code> to trigger state transitions</li> </ol>"},{"location":"examples/basic-usage/","title":"Basic Usage Examples","text":""},{"location":"examples/basic-usage/#available-examples","title":"Available Examples","text":"<ul> <li>Adding a New Character State</li> <li>Trouble Shooting </li> </ul>"},{"location":"examples/troubleshooting/","title":"Debugging State and State Transitions","text":""},{"location":"examples/troubleshooting/#overview","title":"Overview","text":"<p>When developing new states or troubleshooting state transitions, you can create a debug configuration YAML file to test specific scenarios with customized working memories.</p>"},{"location":"examples/troubleshooting/#example-testing-chatingstate","title":"Example: Testing ChatingState","text":"<p>Let's examine how to debug the ChatingState class:</p> <pre><code>@register(name='CHATING', type=\"state\")\nclass ChatingState(BaseState):\n    def __init__(self, character: Character, \n                 character_list: CharacterList, \n                 building_list: BuildingList,  \n                 on_change_state, \n                 followed_states=[CharacterState.SUM],\n                 main_prompt = PromptType.CHATING,\n                 state_name = CharacterState.CHATING,\n                 arbitrary_wm=dict()\n    )    \n</code></pre>"},{"location":"examples/troubleshooting/#creating-a-debug-configuration","title":"Creating a Debug Configuration","text":"<p>You can customize state initialization arguments and working memory using a debug configuration file:</p> <pre><code># config/debug_chat.yaml\nStates:\n  Jack Brown:  \n    ACT:\n        followed_states: \n            - CHATING \n    CHATING: \n        arbitrary_wm: \n            act_obj: Emma Smith\n            init_conversation: Hi, how are you?  \n  Emma Smith:\n    IDLE: {}\n</code></pre>"},{"location":"examples/troubleshooting/#configuration-components","title":"Configuration Components","text":"<ol> <li>Character Configuration: Define states for each character under their name</li> <li>State Parameters: Customize state-specific settings</li> <li><code>followed_states</code>: Define valid state transitions</li> <li><code>arbitrary_wm</code>: Set initial working memory values</li> </ol>"},{"location":"examples/troubleshooting/#running-the-debug-configuration","title":"Running the Debug Configuration","text":"<p>Execute your simulation with the debug configuration:</p> <pre><code>DEBUG=1 python main.py configs/debug_chat.yaml\n</code></pre>"},{"location":"examples/troubleshooting/#best-practices","title":"Best Practices","text":"<ol> <li>Working Memory Testing</li> <li>Use <code>arbitrary_wm</code> to simulate different memory states</li> <li>Test edge cases and boundary conditions</li> <li> <p>Verify memory persistence across state transitions</p> </li> <li> <p>State Transitions</p> </li> <li>Configure <code>followed_states</code> to test transition paths</li> <li> <p>Verify state entry and exit conditions</p> </li> <li> <p>Character Interactions</p> </li> <li>Set up multiple characters to test interactions</li> <li>Verify message passing between states</li> <li>Test concurrent state transitions</li> </ol>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide will walk you through the process of setting up the Town Simulation Service on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.8 or higher</li> <li>Docker and Docker Compose</li> <li>Git</li> <li>A text editor of your choice</li> </ul>"},{"location":"getting-started/installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<pre><code>git clone https://github.com/KingJiongEN/DegentCivil.git\ncd DegentCivil\n</code></pre>"},{"location":"getting-started/installation/#step-2-set-up-python-environment","title":"Step 2: Set Up Python Environment","text":"<p>It's recommended to use a virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows, use: venv\\Scripts\\activate\npip install -r requirements.txt\n</code></pre>"},{"location":"getting-started/installation/#step-3-set-up-docker-services","title":"Step 3: Set Up Docker Services","text":""},{"location":"getting-started/installation/#milvus-setup","title":"Milvus Setup","text":"<ol> <li>Create directories for Milvus:</li> </ol> <pre><code>mkdir milvus\nmkdir milvus/db\nmkdir milvus/minio\n</code></pre> <ol> <li>Start Milvus using Docker Compose:</li> </ol> <pre><code>docker-compose -f docker-compose_milvus.yml up -d\n</code></pre> <p>Milvus visualization will be available at: - URL: <code>localhost:18000</code> - Username: <code>minioadmin</code> - Password: <code>minioadmin</code></p>"},{"location":"getting-started/installation/#redis-setup","title":"Redis Setup","text":"<p>Start Redis using Docker:</p> <pre><code>docker pull redis\ndocker run --name my-redis -p 6379:6379 -d redis\n</code></pre> <p>For a secured Redis instance:</p> <pre><code>docker run --name my-redis-secured -p 6379:6379 -d -v ./redis.conf:/usr/local/etc/redis/redis.conf redis redis-server /usr/local/etc/redis/redis.conf\n</code></pre>"},{"location":"getting-started/installation/#step-4-configuration","title":"Step 4: Configuration","text":"<ol> <li>Create OpenAI configuration:</li> </ol> <pre><code># Create the config directory if it doesn't exist\nmkdir -p config\n# Create OAI_CONFIG_LIST file (you'll need to edit this with your API key)\ntouch config/OAI_CONFIG_LIST\n</code></pre> <ol> <li>Set up your OpenAI API key:</li> </ol> <pre><code>export OPENAI_API_KEY=your_api_key_here\n</code></pre>"},{"location":"getting-started/installation/#step-5-verify-installation","title":"Step 5: Verify Installation","text":"<p>Run the memory demo to verify your installation:</p> <pre><code>export PYTHONPATH=\"{project_path}:$PYTHONPATH\"\npython -m app.models.memory\n</code></pre>"},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/installation/#docker-services","title":"Docker Services","text":"<p>If you encounter issues with Docker services:</p> <ol> <li>Ensure Docker daemon is running:</li> </ol> <pre><code>docker info\n</code></pre> <ol> <li>Check service status:</li> </ol> <pre><code>docker ps\n</code></pre> <ol> <li>View service logs:</li> </ol> <pre><code>docker logs my-redis\ndocker-compose -f docker-compose_milvus.yml logs\n</code></pre>"},{"location":"getting-started/installation/#python-dependencies","title":"Python Dependencies","text":"<p>If you encounter Python dependency issues:</p> <ol> <li>Ensure you're using the correct Python version:</li> </ol> <pre><code>python --version\n</code></pre> <ol> <li>Update pip:</li> </ol> <pre><code>pip install --upgrade pip\n</code></pre> <ol> <li>Reinstall dependencies:</li> </ol> <pre><code>pip install -r requirements.txt --force-reinstall\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Follow our Quick Start Guide to begin using the service</li> <li>Read through Core Concepts to understand the system</li> <li>Check out Examples for common use cases </li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you get started with the Town Simulation Service quickly. We'll create a simple town with a few characters and run basic interactions.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have: - Completed the installation process - Set up your OpenAI API key - Started the required services (Milvus and Redis)</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quick-start/#1-start-the-service","title":"1. Start the Service","text":"<pre><code>DEBUG=1 Milvus=1 python main.py\n</code></pre>"},{"location":"getting-started/quick-start/#2-create-a-simple-town","title":"2. Create a Simple Town","text":"<pre><code>from app.models.town import Town\nfrom app.models.character import Character\nfrom app.models.building import Building\n\n# Initialize a new town\ntown = Town(name=\"MyTown\")\n\n# Add some buildings\ncafe = Building(\n    name=\"Town Cafe\",\n    description=\"A cozy cafe in the heart of town\",\n    building_type=\"COMMERCIAL\"\n)\ntown.add_building(cafe)\n\n# Add characters\nalice = Character(\n    name=\"Alice\",\n    description=\"A friendly cafe owner\",\n    occupation=\"Cafe Owner\",\n    location=cafe\n)\ntown.add_character(alice)\n\n# Start the simulation\ntown.start_simulation()\n</code></pre>"},{"location":"getting-started/quick-start/#3-basic-character-interactions","title":"3. Basic Character Interactions","text":"<pre><code># Get character state\nalice_state = alice.get_current_state()\n\n# Trigger an interaction\nresponse = alice.interact_with(\"What's the special today?\")\nprint(response)\n\n# Update character's location\nnew_location = town.get_building(\"Town Square\")\nalice.update_location(new_location)\n</code></pre>"},{"location":"getting-started/quick-start/#example-scenarios","title":"Example Scenarios","text":""},{"location":"getting-started/quick-start/#1-character-daily-routine","title":"1. Character Daily Routine","text":"<pre><code># Set up a daily routine for Alice\nalice.set_schedule([\n    {\"time\": \"08:00\", \"action\": \"open_cafe\", \"location\": \"Town Cafe\"},\n    {\"time\": \"12:00\", \"action\": \"lunch_break\", \"location\": \"Town Cafe\"},\n    {\"time\": \"17:00\", \"action\": \"close_cafe\", \"location\": \"Town Cafe\"}\n])\n\n# Start the routine\nalice.start_daily_routine()\n</code></pre>"},{"location":"getting-started/quick-start/#2-town-events","title":"2. Town Events","text":"<pre><code># Create a town event\ntown.create_event(\n    name=\"Summer Festival\",\n    description=\"Annual town summer celebration\",\n    location=\"Town Square\",\n    participants=town.get_all_characters()\n)\n\n# Start the event\ntown.start_event(\"Summer Festival\")\n</code></pre>"},{"location":"getting-started/quick-start/#memory-system-usage","title":"Memory System Usage","text":"<pre><code># Add a memory for a character\nalice.add_memory(\n    content=\"Met Bob at the cafe\",\n    importance=0.8,\n    related_entities=[\"Bob\", \"Town Cafe\"]\n)\n\n# Retrieve relevant memories\ncafe_memories = alice.retrieve_memories(\n    query=\"What happened at the cafe today?\",\n    limit=5\n)\n</code></pre>"},{"location":"getting-started/quick-start/#state-management","title":"State Management","text":"<pre><code># Change character state\nalice.change_state(\"BUSY\")\n\n# Check if character can interact\nif alice.can_interact():\n    response = alice.interact_with(\"Hello!\")\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ol> <li>Explore more complex scenarios in our Examples</li> <li>Learn about the Character System</li> <li>Understand State Management</li> <li>Check out API Reference for detailed documentation</li> </ol>"},{"location":"getting-started/quick-start/#common-operations","title":"Common Operations","text":""},{"location":"getting-started/quick-start/#character-management","title":"Character Management","text":"<pre><code># Get all characters\nall_characters = town.get_all_characters()\n\n# Find characters by trait\nmerchants = town.find_characters_by_occupation(\"Merchant\")\n\n# Get character relationships\nalice_relationships = alice.get_relationships()\n</code></pre>"},{"location":"getting-started/quick-start/#building-management","title":"Building Management","text":"<pre><code># Get all buildings\nall_buildings = town.get_all_buildings()\n\n# Find buildings by type\nshops = town.find_buildings_by_type(\"COMMERCIAL\")\n\n# Get building occupants\ncafe_occupants = cafe.get_occupants()\n</code></pre>"},{"location":"getting-started/quick-start/#simulation-control","title":"Simulation Control","text":"<pre><code># Pause simulation\ntown.pause_simulation()\n\n# Resume simulation\ntown.resume_simulation()\n\n# Get simulation status\nstatus = town.get_simulation_status()\n</code></pre>"},{"location":"getting-started/quick-start/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues:</p> <ol> <li>Check the logs:</li> </ol> <pre><code>town.get_logs()\ncharacter.get_logs()\n</code></pre> <ol> <li>Verify service status:</li> </ol> <pre><code>town.check_services_status()\n</code></pre> <ol> <li>Reset character state:</li> </ol> <pre><code>character.reset_state()\n</code></pre> <p>For more detailed information, refer to our Troubleshooting Guide. </p>"}]}